## instance_id

我将train和test结合在一起，置test的'is_trade'=2，然后统计instance_id，发现train里面出现的instance_id，也会在test里面出现，大概有3条。可以根据这个直接给test中重复的instance_id设'is_trade'

## context_timestamp

```python
-----------
train&test
-----------

print((timestamp_max - timestamp_min)/60/60/24)

7.99958333333

对context_timestamp按时间划分进行统计

day_list = [0 for i in range(8)]
for item in data['context_timestamp']:
    day = (item - timestamp_min)//86400
    day_list[day] += 1
print(day_list)

[78268, 70931, 68387, 71199, 68318, 63616, 57419, 18371]

-----------
train
-----------
6.99983796296

该天的数据量： [78268, 70931, 68387, 71199, 68318, 63616, 57419]
转化成功：    [1567, 1396, 1324, 1375, 1289, 1099, 971]
总数据：    [78268, 70931, 68387, 71199, 68318, 63616, 57419]
转化率：    [0.020, 0.020, 0.019, 0.019, 0.019, 0.017, 0.017]

------------
猜测
------------
1. 最后一天test只有18371条数据
2. 第一第二天应该是周末
3.
```

## 所有id作count

有一个问题，到底要不要统计test的数据？算是数据泄露吗？


## 模型运行结果

#### xgboost

```python
params = {'booster': 'gbtree',
              'objective': 'binary:logistic',
              'eval_metric': 'auc',
              'gamma': 0.1,
              'min_child_weight': 1.1,
              'max_depth': 7,
              'lambda': 10,
              'subsample': 0.7,
              'colsample_bytree': 0.7,
              'colsample_bylevel': 0.7,
              'eta': 0.01,
              'tree_method': 'exact',
              'seed': 123,
              'nthread': 12
              }

[1461]	train-auc:0.868962	val-auc:0.660864
Stopping. Best iteration:              
[1161]	train-auc:0.842845	val-auc:0.662198

令max_depth=5也差不多

--------------------------
train 012345 val 6
[737]	train-logloss:0.08924	val-logloss:0.082714


--------------------------
train1 012 val1 3
train2 123 val2 4
train3 234 val3 5
[1186]	train1-auc:0.841679	val1-auc:0.67162
[861]	train2-auc:0.810119	val2-auc:0.682462
[1387]	train3-auc:0.867984	val3-auc:0.664714

train1 0123 val1 4
train2 1234 val2 5
train3 2345 val3 6
[912]	train1-auc:0.796563	val1-auc:0.685643
[622]	train1-logloss:0.089073	val1-logloss:0.089618
[1479]	train2-auc:0.852829	val2-auc:0.666025
[646]	train2-logloss:0.087347	val2-logloss:0.084214
[1024]	train3-auc:0.81983	val3-auc:0.662747
[690]	train3-logloss:0.084551	val3-logloss:0.082746

可以看到，增加了一天训练数据总体来说没有太大变化
--------------------------
```

## Todo

- 对`'item_category_list'`作统计，因为可能某些类目(消耗品)购买的可能性比较高
- `'item_property_list'`有相当的多...目前并不知道这个属性的准确意义，打算对list中按权重加权相加构成新特征，把这个特征去掉
- `'predict_category_property'`
- 看到技术圈有人说。这个现象值得关注？
  `'item_id'`中test在train出现过的个数:18164
  `'item_id'`中test没有在train出现过的个数:207
- 为什么会有一个predict_catagory_property字段？不是和已经有 item_catagory和item_property_list了吗


## 官方关于数据的说明

- 每个广告商品都有类目（category）和属性（property）的字段。一个广告商品，有从大到小的若干个类目，以及没有从属关系的若干个属性。每个广告商品的类目数量不固定，属性数量也不固定。举例说明，某一个广告商品的 item_category_list 可能是“手机;全面屏手机”；这个广告商品的item_property_list 可能是“白色;支持LTE;4.7英寸屏幕”。

- predict_category_property 是根据上下文信息推测出的类目和属性，其中的每一个预测类目对应于若干个（可能为零个）预测属性。举例说明，某一个样本的 predict_category_property 可能对应于“手机:白色,支持LTE,4.7英寸屏幕;水果:红色,球形;公司:-1”，其中 -1 表示预测类目“公司”没有找到适用于当前广告商品的预测属性。

- context_timestamp指的是广告被点击的那个时间点
